# -*- coding: utf-8 -*-
"""LLM_Chatbot_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KwGRvxQEAp1AdH1mi6ye96MsAKUafQ8T
"""

# Install Pinecone client (if not already installed)
!pip install -U pinecone-client

# Import and initialize Pinecone
from pinecone import Pinecone, ServerlessSpec

import os
from pinecone import Pinecone

api_key = os.getenv("PINECONE_API_KEY")
openai.api_key = os.getenv("OPENAI_API_KEY")

pc = Pinecone(api_key=api_key, environment="us-east-1")


# Initialize the Pinecone instance
pc = Pinecone(api_key=api_key)

# Retrieve and print the list of indexes
indexes = pc.list_indexes().names()
print("Indexes in the environment:")
for index in indexes:
    print(index)

!pip install openai==0.28

import openai
import pandas as pd
import numpy as np

from pinecone import Pinecone, ServerlessSpec


index_name = "promo-roi-file"

# Connect to the index
index = pc.Index(index_name)

"""# **Explain variables to GPT (Prompt Engineering)**"""

variables_explanation = """
    Below are the definitions of key business terms and variables:

    1. **List_Price**: The price at which an item is sold to the retailer or customer by the manufacturer.
    2. **Customer**: The name of the customer, retailer, or banner.
    3. **Week_Type**: Indicates whether the week is a promotion week or a non-promotion week.
    4. **Merch**: The method or vehicle used to execute the promotion (e.g., ISF_&_Flyer, ISF_Only, ISF_&_Ad).
    5. **Base_Units**: The number of units sold during a non-promotion week.
    6. **Item**: The name of the item sold by the manufacturer to the retailer and subsequently to the consumer.
    7. **Base_Price**: The selling price of an item in a non-promotion week.
    8. **Promo_Price**: The selling price of an item during a promotion week.
    9. **Price**: The price of an item during a given week. Equal to Base_Price if the item is not on promotion, or Promo_Price if it is.
    10.**Base_Retailer_Margin_Unit**: The retailer margin per unit during a non-promotion week. It is calculated as (Base_Price - List_Price + EDLP_Trade_Unit).
    11. **Promo_Units**: The number of units sold during a promotion week.
    12. **Units**: The total number of units sold during a given week (Base_Units if no promotion, Promo_Units if on promotion).
    13. **Predicted_Units**: The number of units predicted by the model for a given week.
    16. **COGS_Unit**: The cost to produce or manufacture the item.
    17. **Margin_%**: The retailer margin percentage, calculated as (Price - List_Price + Trade_Unit) / Price.
    19. **Base_Retailer_Margin_Unit**: The retailer margin per unit during a non-promotion week, calculated as (Base_Price - List_Price + EDLP_Trade_Unit) / Base_Price. This equal to Margin_% if the week is a non-promotion week.
    20. **Min_Margin_%**: The minimum retail margin required each week.
    21. **EDLP_Trade_Unit**: The allowance per unit given to the customer or retailer when the item is not on promotion.
    22. **Var_Trade_Unit**: Additional allowance per unit given during a promotion week.
    23. **Trade_Unit**: The total amount paid back to the retailer or customer to achieve the desired retail selling price.
    24. **Trade_Rate**: Defined as Trade_Unit / List_Price.
    25. **Profit_Unit**: The net profit on the item after all costs and allowances.
    26. **%_Profit_Unit**: The percentage of profit per unit, calculated as Profit_Unit / List_Price.
    27. **Lift_%**: The increase in unit volume during promotion vs. non-promotion periods, calculated as (Promo_Units - Base_Units) / Base_Units.
    28. **Inc_Profit**: Incremental profit when sold on promotion vs. no promotion.
    29. **ROI**: Return on investment from running a promotion in a given week, calculated as Inc_Profit / (Promo_Units * Var_Trade_Unit).
    31. **Discount**: The dollar discount offered during a promotion, calculated as (Base_Price - Promo_Price).
    32. **Predicted_Sales**: The dollar sales of an item sold during a week, calculated as Predicted_Units * Price.
    33. **Predicted_Base_Sales**: The predicted dollar sales assuming the week was a non-promotion week.
    """

formula_functions = {
        "Margin_%": "lambda Base_Price, Promo_Price, List_Price, EDLP_Trade_Unit, Var_Trade_Unit, Week_Type: "
                    "(Base_Price - List_Price + EDLP_Trade_Unit) / Base_Price if Week_Type == 'Base' else "
                    "(Promo_Price - List_Price + EDLP_Trade_Unit + Var_Trade_Unit) / Promo_Price",

        "Trade_Unit": "lambda EDLP_Trade_Unit, Var_Trade_Unit, Week_Type: "
                      "EDLP_Trade_Unit if Week_Type == 'Base' else EDLP_Trade_Unit + Var_Trade_Unit",

        "Trade_Rate": "lambda Trade_Unit, List_Price: Trade_Unit / List_Price",

        "Profit_Unit": "lambda List_Price, COGS_Unit, EDLP_Trade_Unit, Var_Trade_Unit, Week_Type: "
                      "List_Price - COGS_Unit - EDLP_Trade_Unit if Week_Type == 'Base' else "
                      "List_Price - COGS_Unit - (EDLP_Trade_Unit + Var_Trade_Unit)",

        "Profit_Unit_Percentage": "lambda Profit_Unit, List_Price: Profit_Unit / List_Price",

        "Lift_%": "lambda Promo_Units, Base_Units: (Promo_Units - Base_Units) / Base_Units if Week_Type == 'Base' else 0",

        "Inc_Profit": "lambda Promo_Units, Base_Units, List_Price, COGS_Unit, EDLP_Trade_Unit, Var_Trade_Unit: "
                      "(Promo_Units * (List_Price - COGS_Unit - EDLP_Trade_Unit - Var_Trade_Unit)) - "
                      "(Base_Units * (List_Price - COGS_Unit - EDLP_Trade_Unit)) if Promo_Units > 0 else 0",

        "ROI": "lambda Inc_Profit, Var_Trade_Unit, Promo_Units: Inc_Profit / (Promo_Units * Var_Trade_Unit) "
              "if Var_Trade_Unit > 0 else 0",

        "Discount": "lambda Base_Price, Promo_Price: (Base_Price - Promo_Price) / Base_Price * 100 if Base_Price > 0 else 0"
      }

available_formulas = {
        "Discount": ["discount", "price discount", "percentage off", "discounted price"],
        "Customer": ["customer", "retailer", "store, banner"],
        "Week_Type": ["week type", "promotion week", "non-promotion week"],
        "Merch": ["merch", "promotion method", "promotion type, Merchandizing", "Merchandizing strategy"],
        "Item": ["item", "product", "product name"],
        "Lift_%": ["unit lift", "percentage lift", "lift in units", "% lift", "sales lift"],
        "Margin_%": ["margin", "retailer margin", "retail margin", "customer margin"],
        "Min_Margin_%": ["min margin", "minimum margin", "minimum retail margin"],
        "Trade_Unit": ["trade per unit", "allowance per unit", "total allowance", "trade allowance"],
        "Trade_Rate": ["trade rate", "rate of trade", "% trade investment"],
        "Profit_Unit": ["profit per unit", "unit profit", "profit per item"],
        "%_Profit_Unit": ["profit percentage", "unit profit percentage", "% profit per unit"],
        "Inc_Profit": ["incremental profit", "added profit", "promo profit", "incremental sales profit"],
        "%_ROI": ["roi", "return on investment", "promo roi", "return on trade investment"],
        "Base_Retailer_Margin_Unit": ["base retailer margin per unit", "base retailer margin per item"],
        "Retailer_Margin_Unit": ["retailer margin per unit", "retailer margin per item"],
        "Predicted_Units": ["Units", "Total Units"],
        "Predicted_Base_Units": ["Base Units, Total Base Units"],
        "Predicted_Base_Sales": ["Base Sales, Total Base Sales, Dollar Base Sales"],
        "Predicted_Sales": ["Sales, Total Sales, Dollar Sales"]
        }

def explain_variables_to_gpt(variables_explanation, formula_functions, available_formulas):

    # Send the explanation to GPT-4
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are an assistant that understands business terminologies for determining promotions effectiveness."},
            {"role": "user", "content": f"Variables Explanation: {variables_explanation}\nFormula Functions: {formula_functions}\nAvailable Formulas: {available_formulas}"}
        ],
        max_tokens=500
    )

    # Return the response from GPT-4
    return variables_explanation, formula_functions, available_formulas, response['choices'][0]['message']['content']

variables_explanation, formula_functions, available_formulas, response = explain_variables_to_gpt(variables_explanation, formula_functions, available_formulas)
print(response)

"""# **Sample User Queries**"""

test_queries = [
    "Which promotion will drive the highest unit volume lift for item_177 at customer Metro_Quebec?",  # Predictive analysis
    "I have 5 weeks of promo opportunity at Metro_Ontario. Can you help me create a promotion plan?",  # Trade plan
    "Tell me all promotions available for item_177 at customer Metro_Ontario.",  # Information retrieval
    "Tell me which promotion will have the highest sales when item_177 is sold on promo at Customer_Name Metro_Ontario (Metro_Ontario is the name of the Customer and can be found under Column named 'Customer' in the DataFrame 'data_set')?",
    "Tell me which promotion will have the highest sales when item_177 is sold on promo at Metro_Ontario?",
    "Tell me which Banner will provide the highest unit sales for item_177 when it is sold on promotion?",
    "Give me top 5 promotions for item_177 at Metro_Ontario. Top promotion is defined as highest ratio of (Units sold on promotion)/(Units sold when item is not on promotion)?",
    "I can have 5 weeks of promotions between item_177 & item_189 at Metro_Ontario but no promotion should be used more than twice. Can you give me list of promotions (5 in total) which would drive the highest volume sales?",
    "I want to develop a best promotion plan for Metro_Ontario banner by running 5 promotions which would give me the highest unit volume sales.",
    "Tell me what is the difference between user_prompt_5 & user_prompt_1.",
    "I want to see the difference in unit volume for item_177 at Metro_Ontario (Name of the Customer which can be found in 'df' under column 'Customer') for all promotions if I increase the price by 10%.",
    "Calculate return on investment for an item sold for $4.99 without promotion and $3.99 during promotion with a 125% volume increase and 15% customer margin."
]

user_query = test_queries[0]

user_query

"""# **Generate Intent & Steps**"""

# Function to generate intent and detailed plan using GPT-4
def generate_intent_and_steps(user_query, response):
    """
    Uses GPT-4 to determine the user's intent and outline steps needed to process the user request.
    The function incorporates user-specified requirements along with business-specific definitions and formulas.

    Parameters:
    - user_query: The user's question or request.
    - gpt_response: General explanation of the model's functionality.
    - variables_explanation: Explanation of the key business variables.
    - formula_functions: Formula definitions and functions used in the business context.
    - available_formulas: Alternative names or synonyms for formulas.

    Returns:
    - A structured response from GPT-4 detailing the intent, action steps, and ranking metric (if specified).
    """
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {
                "role": "system",
                "content": (
                    "You are an assistant that understands business terminology and can extract user intents, determine ranking metrics, and provide detailed action steps for processing data."
                    "return the intent, detailed action steps and ranking metric (e.g., 'ROI', 'Lift', 'Unit Sales') if specified. Query: '{user_query}'"
                    )
            },
            {
                "role": "user",
                "content": (
                    f"Model Explanation: '{response}'\n"
                    f"User query: '{user_query}'\n\n"
                    "Please extract relevant terms found in variables explanation and connect them to the user's query. "
                    "Then, identify the intent and list steps to process this data using available variables and formulas. "
                    "Use these resources to support your response:\n"
                    f"1. Variables Explanation: {variables_explanation}\n"
                    f"2. Formula Functions: {formula_functions}\n"
                    f"3. Available Formulas: {available_formulas}\n\n"
                    "If the user has specified a ranking metric (e.g., 'ROI', 'Lift', 'Unit Sales'), include it in the response as 'ranking_metric'."
                )
            }
        ],
        max_tokens=500
    )

    # Parse the intent and steps from GPT-4's response
    try:
        intent_and_steps = response['choices'][0]['message']['content'].strip()
        return intent_and_steps
    except KeyError as e:
        print(f"Error extracting response content: {e}")
        return "Error: Unable to parse the response from GPT-4."

intent = generate_intent_and_steps(user_query, response)
print(intent)

"""# **Determine Query Type**"""

def query_type(user_query):
    """
    Classifies the user's query and then determines which workflow (Predictive analysis, Trade plan, or Info retrieval)
    to follow based on semantic understanding using GPT-4.
    """
    classification_prompt = f"""
    I am building an AI assistant that handles user queries related to trade promotions. It has the following workflows:

    1. Predictive analysis: When the user wants to predict the performance of a promotion or get insights into which promotion will perform best.
    2. Trade plan creation: When the user wants to create a promotion plan that maximizes sales, ROI, units over a period of time.
    3. Information retrieval: When the user just wants to retrieve specific data or information without predictions.
    4. Perform Calculations: When the user wants to determine the values of certain variables using formulas in {formula_functions}. User would have already provided the values of some of these variables and then you would just use the right formula to calculate the remaining variables.

    Please classify the following query into one of these workflows: "{user_query}"

    Reply with only one of the following: "Predictive analysis", "Trade plan creation", "Information retrieval" or "Perform Calculations".
    """

    # Step 1: Classify the intent and workflow
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "system", "content": classification_prompt}],
        max_tokens=200  # Ensure enough tokens for response
    )

    # Extract the classification
    workflow = response['choices'][0]['message']['content'].strip()


    return workflow

query_type(user_query)

def extract_variables_from_query(intent):
    """
    Use GPT-4 to extract relevant variables from the user query, which will later be used for querying
    the dataset to extract the appropriate promotion effectiveness details.
    """
    # Use GPT-4 to extract variables
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are an assistant that extracts key filtering variables from a user query. Your response should return a JSON object of extracted variables only."},
            {"role": "user", "content": f"Extract the relevant variables from the following user query: '{intent}'. Respond only with a Python dictionary containing relevant column names as keys and values as filter values, plus a 'ranking_metric' key indicating the ranking metric (default to 'ROI' if not specified) without additional text or explanation."}
        ],
        max_tokens=150
    )

    # parse and return extracted variables as JSON dictionary
    extracted_variables = response['choices'][0]['message']['content']
    try:
      variables_dict = eval(extracted_variables)
      if isinstance(variables_dict, dict):
        return variables_dict
      else:
        raise ValueError("GPT-4 did not return a dictionary.")

    except Exception as e:
      print(f"Error parsing GPT-4 response: {e}")
      return {}

extract_variables = extract_variables_from_query(intent)

print(extract_variables)

type(extract_variables)





def process_query_semantically(user_query):

    workflow = query_type(user_query)

    if workflow == "Predictive analysis":
        result = filter_dataset_from_pinecone(intent)  # Pass intent
    elif workflow == "Trade plan creation":
        result = handle_trade_plan(user_query, reference_df)
    elif workflow == "Information retrieval":
        result = handle_info_retrieval(user_query, reference_df)
    else:
        result = "Unable to classify the query into a known workflow. Please refine your query."

    return result

process_query_semantically(user_query)

"""# **Get Data From Pinecone**"""

